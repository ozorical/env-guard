{"version":3,"sources":["../src/index.ts","../src/validate.ts"],"sourcesContent":["import { validateEnv } from \"./validate\";\r\nimport { EnvSchema } from \"./types\";\r\n\r\nexport function env<T extends EnvSchema>(schema: T) {\r\n  return validateEnv(schema) as {\r\n    [K in keyof T]: any;\r\n  };\r\n}\r\n","import { EnvSchema, EnvRule } from \"./types\";\r\n\r\ntype ObjectRule = Exclude<EnvRule, string | readonly string[]>;\r\n\r\nfunction isObjectRule(rule: EnvRule): rule is ObjectRule {\r\n  return typeof rule === \"object\" && !Array.isArray(rule);\r\n}\r\n\r\nfunction cast(value: string, type: string) {\r\n  if (type === \"number\") {\r\n    const n = Number(value);\r\n    if (Number.isNaN(n)) throw new Error(\"Expected number\");\r\n    return n;\r\n  }\r\n\r\n  if (type === \"boolean\") {\r\n    if (value === \"true\") return true;\r\n    if (value === \"false\") return false;\r\n    throw new Error(\"Expected boolean\");\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nexport function validateEnv(schema: EnvSchema) {\r\n  const output: Record<string, any> = {};\r\n  const errors: string[] = [];\r\n\r\n  for (const key in schema) {\r\n    const rule = schema[key];\r\n    const raw = process.env[key];\r\n\r\n    if (typeof rule === \"string\") {\r\n      if (!raw) {\r\n        errors.push(`${key} is required`);\r\n        continue;\r\n      }\r\n      output[key] = cast(raw, rule);\r\n      continue;\r\n    }\r\n\r\n    if (Array.isArray(rule)) {\r\n      if (!raw) {\r\n        errors.push(`${key} is required`);\r\n        continue;\r\n      }\r\n      if (!rule.includes(raw)) {\r\n        errors.push(`${key} must be one of: ${rule.join(\", \")}`);\r\n        continue;\r\n      }\r\n      output[key] = raw;\r\n      continue;\r\n    }\r\n\r\n    if (isObjectRule(rule)) {\r\n      if (!raw) {\r\n        if (rule.optional) continue;\r\n        if (rule.default !== undefined) {\r\n          output[key] = rule.default;\r\n          continue;\r\n        }\r\n        errors.push(`${key} is required`);\r\n        continue;\r\n      }\r\n\r\n      try {\r\n        output[key] = cast(raw, rule.type);\r\n      } catch {\r\n        errors.push(`${key} must be ${rule.type}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (errors.length) {\r\n    throw new Error(\r\n      \"Environment validation failed:\\n\" +\r\n      errors.map(e => `- ${e}`).join(\"\\n\")\r\n    );\r\n  }\r\n\r\n  return output;\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACIA,SAAS,aAAa,MAAmC;AACvD,SAAO,OAAO,SAAS,YAAY,CAAC,MAAM,QAAQ,IAAI;AACxD;AAEA,SAAS,KAAK,OAAe,MAAc;AACzC,MAAI,SAAS,UAAU;AACrB,UAAM,IAAI,OAAO,KAAK;AACtB,QAAI,OAAO,MAAM,CAAC,EAAG,OAAM,IAAI,MAAM,iBAAiB;AACtD,WAAO;AAAA,EACT;AAEA,MAAI,SAAS,WAAW;AACtB,QAAI,UAAU,OAAQ,QAAO;AAC7B,QAAI,UAAU,QAAS,QAAO;AAC9B,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AAEA,SAAO;AACT;AAEO,SAAS,YAAY,QAAmB;AAC7C,QAAM,SAA8B,CAAC;AACrC,QAAM,SAAmB,CAAC;AAE1B,aAAW,OAAO,QAAQ;AACxB,UAAM,OAAO,OAAO,GAAG;AACvB,UAAM,MAAM,QAAQ,IAAI,GAAG;AAE3B,QAAI,OAAO,SAAS,UAAU;AAC5B,UAAI,CAAC,KAAK;AACR,eAAO,KAAK,GAAG,GAAG,cAAc;AAChC;AAAA,MACF;AACA,aAAO,GAAG,IAAI,KAAK,KAAK,IAAI;AAC5B;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,UAAI,CAAC,KAAK;AACR,eAAO,KAAK,GAAG,GAAG,cAAc;AAChC;AAAA,MACF;AACA,UAAI,CAAC,KAAK,SAAS,GAAG,GAAG;AACvB,eAAO,KAAK,GAAG,GAAG,oBAAoB,KAAK,KAAK,IAAI,CAAC,EAAE;AACvD;AAAA,MACF;AACA,aAAO,GAAG,IAAI;AACd;AAAA,IACF;AAEA,QAAI,aAAa,IAAI,GAAG;AACtB,UAAI,CAAC,KAAK;AACR,YAAI,KAAK,SAAU;AACnB,YAAI,KAAK,YAAY,QAAW;AAC9B,iBAAO,GAAG,IAAI,KAAK;AACnB;AAAA,QACF;AACA,eAAO,KAAK,GAAG,GAAG,cAAc;AAChC;AAAA,MACF;AAEA,UAAI;AACF,eAAO,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI;AAAA,MACnC,QAAQ;AACN,eAAO,KAAK,GAAG,GAAG,YAAY,KAAK,IAAI,EAAE;AAAA,MAC3C;AAAA,IACF;AAAA,EACF;AAEA,MAAI,OAAO,QAAQ;AACjB,UAAM,IAAI;AAAA,MACR,qCACA,OAAO,IAAI,OAAK,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI;AAAA,IACrC;AAAA,EACF;AAEA,SAAO;AACT;;;AD9EO,SAAS,IAAyB,QAAW;AAClD,SAAO,YAAY,MAAM;AAG3B;","names":[]}